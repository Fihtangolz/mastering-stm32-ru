25.2 Дизайн прошивки

Когда вы закончите проектировку аппаратного обеспечения, вы можите приступить разрабатывать программную часть. If you have used CubeMX to design the MCU section of your custom board, you should be able to start coding the firmware really quickly. If the CubeMX project observes faithfully the actual board design, you can simply generate the project as we have done for the Nucleo development board, then you can import it inside a new Eclipse project and start working on your application. Nothing different from what described in Chapter 4. If you have already developed the firmware using a development board, and you need to adapt it to your custom design, you may proceed in this way: 
• Generate a fresh new CubeMX project both for your development board (e.g. the NucleoF030),   enabling the needed peripherals, and for the custom board you have designed. 
Do a comparison between the initialization routines for the used peripherals: if they differ, start replacing them one by one in the project made for the development board, and do a complete project compilation before to continue with the next peripheral. This will allow you to keep the control of what is changing in your firmware. 
 To simplify the porting process, never change the peripheral initialization code generated by CubeMX, but use CubeMX to change peripheral settings.  
Try to use macros to wrap peripheral handlers. Once you change them, you only need to redefine the macros (for example, if your firmware developed with the Nucleo uses the USART2 peripheral, define a global macro in this way: #define USART_PERIPHERAL huart2 and base your code on that macro; if your new design uses the USART1, then you have to redefine only that macro accordingly). Remember that CubeMX essentially generates 5 or 6 files. If you reduce the modification to these files at minimum, it will be easy to rearrange the code. Having a minimum viable firmware made with a development kit helps a lot during the debugging of your custom board. It happens really often that, during the testing of a new board, you are in doubt if your issues arise from the hardware or the software. Knowing that the firmware works simplifies the hardware debugging stage. 25.2.1 Generating the binary image for production In large organizations, who effectively loads the binary image of the firmware on the final board is a completely different person. As as engineer, you may be asked to generate an image of the final firmware in release mode. This is a way to indicate a binary image of the firmware compiled with the highest possible optimization level, in order to reduce the final size of the image, and without including any debug information. This last requirement is needed both to reduce the size of binary image and to protect the intellectual property (the ELF file of a firmware compiled with debug Getting Started With a New Design 751 symbols usually contains the whole firmware source code, so that GDB can show you the original source code while debugging). From the Eclipse/GCC point of view, generating a binary image in release mode is nothing more than to configure the project accordingly. You might have already noticed that every new Eclipse project comes with two Build Configurations (go to Project->Build Configurations->Manage menu if you have never used this feature before): one named Debug and one Release. A build configuration is nothing more than a project configuration, and you can have as many separated configurations as you want in a single project.

Figure 11 shows the project settings dialog (go to Project->Properties menu to open it). The C/C++ Build->Settings pane allows to configure the build options. Moreover, as you can see in Figure 11, you can quickly move to another build configuration using the Configuration combo-box. In the Optimization section we can setup the GCC optimization levels. GCC provides 5 optimization levels. Let us briefly introduce them:

-O0: this corresponds to the no optimization level. It generates unoptimized code but usually has the fastest compilation time. Note that other compilers do fairly extensive optimization even if no optimization is specified. With GCC, it is very unusual to use -O0 for production if execution time is of any concern, since -O0 really does mean no optimization at all. This difference between GCC and other compilers should be kept in mind when doing performance comparisons.
-O1: this corresponds to a moderate optimization. It optimizes reasonably well but does not degrade compilation time significantly. 
 -O2: this corresponds to full optimization. It generates highly optimized code and has the slowest compilation time.  
-O3: this also corresponds to full optimization as in “-O2”, but it also uses more aggressive automatic inlining of subprograms within a unit and attempts to vectorize loops. 
-Os: this corresponds to optimization for space. It optimize space usage (both code and data) of resulting program. 
-Og: this corresponds to optimization for debug. It enables optimizations that do not interfere with debugging. It should be the optimization level of choice for the standard edit-compiledebug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience.

По умолчанию, уровень оптимизации GCC для конфигурации Release установлен на -Os. Более высокие уровни оптимизации совершают больше глобальных преобразований над программой и применяют более дорогостоящие алгоритмы анализа для генерации более быстрого и компактного кода. Однако, в эмбедед программировании, обычно предлагается начать разработку используя оптимизации (-O0). Так как, более агресиваная оптимизация, может вызывать разное поведение для ограниченных во времени исполнения функций. Эмпирическое правило, разработайте вашу прошивку используя -O0 или -Og уровень оптимизации, и начните увеличивать в процессе тестируя реализованный функционал. Иногда, так же случается, что прошивка отлично работает при компиляции с флагом -O0 и перестает работать вообще при выборе более агрессивной оптимизации. Это часто случается мы неправильно объявляем общие(shared) и глобальные переменные с модификатором volatile и они оптимизируются, что вызывает неправильное поведение ISR функций или различных потоков(threads) при использовании RTOS. Another important configuration parameter for the Release configuration is related to Debug level. This feature is configured inside the Debugging view, and GCC offers four increasing levels: None, -g1, -g (the default in Release configuration) and -g3. If you want to generate a binary image without debug information, select the None level.
